<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wu's Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 05 Aug 2018 12:52:40 +0800</pubDate>
    <lastBuildDate>Sun, 05 Aug 2018 12:52:40 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>蒙特卡罗方法的数学基础</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文是我在 &lt;a href=&quot;www.scratchapixel.com&quot;&gt;scratchapixel&lt;/a&gt; 的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;h3 id=&quot;快速介绍&quot;&gt;快速介绍&lt;/h3&gt;

&lt;p&gt;生活中的许多事情都难以准确评估，特别是涉及到非常大的数字的时候。例如计算一个国家的成年人口的平均身高，我们不太可能去统计每一个人的身高，而是取一个人口样本并计算其平均身高，得出其结果作为近似值。虽然结果并不十分精确，但随着样本的大小增加，近似值与实际结果之间的误差随着样本量的增加而变小。这是一种用准确性换取时间的方法。
&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Approximation(Average(X))&amp;space;=&amp;space;{&amp;space;1&amp;space;\over&amp;space;N}&amp;space;\sum_{n=1}^N&amp;space;x_n.&quot; alt=&quot;Approximation(Average(X)) = { 1 \over N} \sum_{n=1}^N x_n.&quot; /&gt;
注意，这里的X是一个&lt;strong&gt;随机变量&lt;/strong&gt;（如前面每个人的高度），在统计中，随机变量X的平均值称为&lt;strong&gt;期望值&lt;/strong&gt;，写为E(X)。
&lt;img src=&quot;http://latex.codecogs.com/gif.latex?E(X)&amp;space;\approx&amp;space;{&amp;space;1&amp;space;\over&amp;space;N&amp;space;}&amp;space;\sum_{n&amp;space;=&amp;space;1}^N&amp;space;x_n.&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;运用蒙特卡罗方法的光线追踪&quot;&gt;运用蒙特卡罗方法的光线追踪&lt;/h3&gt;

&lt;p&gt;在计算机中，图片的每一个像素都被保存为单一颜色，而这个颜色应该由每个像素「看到」的全部颜色共同决定的。如图，&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/areacam1.png?&quot; alt=&quot;图1&quot; /&gt;
理想情况下，每个像素的颜色应该这么计算：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?L_{pixel}&amp;space;=&amp;space;\int_{pixel&amp;space;area}&amp;space;L(x_p)&amp;space;dA,&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而，我们可以通过在像素区域中选择几个随机样本位置并平均它们的颜色，求得每个像素的颜色:&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/areacam2.png?&quot; alt=&quot;3&quot; /&gt;
公式如下：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?L_{pixel}&amp;space;\approx&amp;space;{1&amp;space;\over&amp;space;N&amp;space;}&amp;space;\sum_{n=1}^N&amp;space;L(x_n),&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种方法是有缺陷的。首先它的结果并不是精确的，其次是每次计算都会得到不同的结果。我们可以通过增加样本数量来克服这些问题。但是，要将误差减少一半，你需要两倍的样本。换句话说，它们的收敛速度（随着样本数量的增加，它们收敛到正确结果的速度）非常低。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration01.png?&quot; alt=&quot;&quot; /&gt;
上面是随机取8个样本的结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration03.png?&quot; alt=&quot;&quot; /&gt;
上面是随机取样，每种进行16次计算的结果。&lt;/p&gt;

&lt;p&gt;每次计算结果的差异程度也取决于网格颜色之间的变化程度。如图：&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration04.png?&quot; alt=&quot;&quot; /&gt;我们可以看到其计算的差异程度远远大于前一个例子。&lt;/p&gt;

&lt;p&gt;我们用于计算的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;fstream&amp;gt; 
#include &amp;lt;cstdlib&amp;gt; 
#include &amp;lt;cstdio&amp;gt; 
 
int main(int argc, char **argv) 
{ 
        std::ifstream ifs; 
        ifs.open(&quot;./tex.pbm&quot;); 
        std::string header; 
        uint32_t w, h, l; 
        ifs &amp;gt;&amp;gt; header; 
        ifs &amp;gt;&amp;gt; w &amp;gt;&amp;gt; h &amp;gt;&amp;gt; l; 
        ifs.ignore(); 
        unsigned char *pixels = new unsigned char[w * h * 3]; 
        ifs.read((char*)pixels, w * h * 3); 
        // sample
        int nsamples = 8; 
        srand48(13); 
        float avgr = 0, avgg = 0, avgb = 0; 
        float sumr = 0, sumg = 0, sumb = 0; 
        for (int n = 0; n &amp;lt; nsamples; ++ n) { 
                float x = drand48() * w; 
                float y = drand48() * h; 
                int i = ((int)(y) * w + (int)(x)) * 3; 
                sumr += pixels[i]; 
                sumg += pixels[i + 1]; 
                sumb += pixels[i + 2]; 
        } 
        sumr /= nsamples; 
        sumg /= nsamples; 
        sumb /= nsamples; 
        for (int y = 0; y &amp;lt; h; ++y) { 
                for (int x = 0; x &amp;lt; w; ++x) { 
                        int i = (y * w + x) * 3; 
                        avgr += pixels[i]; 
                        avgg += pixels[i + 1]; 
                        avgb += pixels[i + 2]; 
                } 
        } 
        avgr /= w * h; 
        avgg /= w * h; 
        avgb /= w * h; 
        printf(&quot;Average %0.2f %0.2f %0.2f, Approximation %0.2f %0.2f %0.2f\n&quot;, avgr, avgg, avgb, sumr, sumg, sumb); 
        delete [] pixels; 
        return 0; 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果随着样本大小增加，其结果收敛到预期的值，则估计值是&lt;strong&gt;无偏&lt;/strong&gt;的。结果收敛到其他的值，则估计值是&lt;strong&gt;有偏&lt;/strong&gt;的。看起来，无偏估计似乎比有偏估计更好。但如果偏差足够小并且有偏估计比无偏估计收敛得更快，又或者有偏估计比无偏估计的方差小，那么你可以考虑选择有偏估计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration05.png?&quot; alt=&quot;&quot; /&gt;
假如我们要得到从摄像机看到的P点的颜色，我们需要计算照射到P点上半球面的光线。&lt;img src=&quot;http://latex.codecogs.com/gif.latex?L_P&amp;space;=&amp;space;\int_\Omega&amp;space;L_\Omega.&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，我们可以选择在半球上取样，以获得到达P的光的近似值。&lt;img src=&quot;http://latex.codecogs.com/gif.latex?L_P&amp;space;\approx&amp;space;{&amp;space;1&amp;space;\over&amp;space;N&amp;space;}&amp;space;\sum_{n=1}^N&amp;space;L_n.&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个过程是可以递归的,我们使用递归过程来计算到达可见点P的光。&lt;img src=&quot;http://www.scratchapixel.com/images/upload/monte-carlo-methods/mcintegration06.png?&quot; alt=&quot;&quot; /&gt;
代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vec3f monteCarloIntegration(P, N) 
{ 
    Vec3f lightAtP = 0; 
    int nsamples = 8; 
    for (int n = 0; n &amp;lt; nsamples; ++n) { 
        Ray sampleRay = sampleRayAboveHemisphere(P, N); 
        Vec3f Phit; 
        Vec3f Nhit; 
        if (traceRay(sampleRay, Phit, Nhit)) { 
            lightAtP += monteCarloIntegration(Phit, Nhit); 
        } 
    } 
    lightAtP /= nsamples; 
 
     return lightAtP; 
} 
 
void render() 
{ 
    Ray r; 
    computeCameraRayDir(r, ...); 
    Vec3f Phit; 
    Vec3f Nhit; 
    if (traceRay(r, Phit, Nhit)) { 
        Vec3f lightAtP = monteCarloIntegration(Phit, Nhit); 
        ... 
    } 
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Aug 2018 09:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/05/MC_Methods/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/05/MC_Methods/</guid>
        
        <category>计算机图形学</category>
        
        <category>翻译</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>个人博客搭建完成</title>
        <description>&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;今天使用 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; + &lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;huxblog boilerplate&lt;/a&gt; + &lt;a href=&quot;https://github.com/imsun/gitment&quot;&gt;gitment&lt;/a&gt; 搭建了个人博客。&lt;/p&gt;

</description>
        <pubDate>Sat, 04 Aug 2018 18:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/04/hello-blog/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/04/hello-blog/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
